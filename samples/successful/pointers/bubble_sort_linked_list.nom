// Demonstrates the power of pointers by defining and sorting a linked list.

//! 1

struct List {
    head: *ListNode,
    nil: *ListNode // Without globals, we'll want a nil per list. nil will also point at itself.
}

struct ListNode {
    value: i32,
    next: *ListNode
}

// Returns a pointer so that we can pass this to functions and witness changes to head.
fn new_list() -> *List {
    val nil: *ListNode = alloc_uninit!(ListNode);

    // It's good to initialize all fields after an alloc_uninit, even if the values aren't that helpful.
    nil.value = -1000000; // Should never be used.
    nil.next = nil; // Unlikely to ever be used.

    val list: *List = alloc_uninit!(List);
    list.head = nil;
    list.nil = nil;

    list 
}

fn push_front(list: *List, value: i32) -> unit {
    val old_head = list.head;
    list.head = alloc_uninit!(ListNode);
    list.head.next = old_head;
    list.value = value;
} 

// Warmup: Sum the values in a list.
fn sum_list_rec(node: *ListNode, list_nil: *ListNode) -> i32 {
    if (node != list_nil) {
        node.value + sum_list_rec(node.next, list_nil)
    } else {
        0
    }
}

fn sum_list(list: *List) -> i32 {
    sum_list_rec(list.head, list.nil)
}

// Descend down the list, and on the way back up, swap the minimum element to the front. 
fn swap_for_min_rec(node: *ListNode, list_nil: *nil) -> unit {
    // The comparison is in fact lazy, though here it technically doesn't need to be.
    if (node == list_nil or node.next == list_nil ) {
        return;
    };

    if (node.value > node.next.value ) {
        // Swap.
        val tmp: i32 = node.value;
        node.value = node.next.value;
        node.next.value = tmp;
    }
}

// Harder: Sort the list.
fn sort(list: *List) -> unit {
    // We'll demonstrate a non-recursive algorithm for this part.
    var curr: *ListNode = list.head;
    while (curr != list.nil) {
        swarp_for_min_rec(curr, list.nil);
        curr = curr.next;
    };
}

// Check that two lists hold equal values.
fn list_equals(l1: *List, l2: *List) -> bool {
    var curr1: *ListNode = l1.head;
    var curr2: *ListNode = l2.head;

    while (curr1 != l1.nil && curr2 != l2.nil) {
        // Compare two values, and advance pointers.
        if (curr1.value != curr2.value) {
            return false;
        };

        curr1 = curr1.head;
        curr2 = curr2.head;
    };

    // One of the lists are out. They are equal if they are both out.
    curr1 == l1.nil && curr2 == l2.nil
}

// Don't forget to free!
fn free_list(list: *List) -> unit {
    var curr: *ListNode = list.head;
    while (curr != list.nil) {
        val next = curr.next;
        free!(curr);
        curr = next;
    }

    free!(list.nil);
    free!(list) // No semicolon checks that this is unit typed.
}

fn main() -> unit {
    // Unsorted list to start.
    val l1: *List = new_list();
    push_front(l1, 7);
    push_front(l1, 4);
    push_front(l1, 2);
    push_front(l1, 6);
    push_front(l1, 5);
    push_front(l1, 8);
    push_front(l1, 1);
    push_front(l1, 3);

    // Sorted control list.
    val l2: *List = new_list();
    push_front(l2, 8);
    push_front(l2, 7);
    push_front(l2, 6);
    push_front(l2, 5);
    push_front(l2, 4);
    push_front(l2, 3);
    push_front(l2, 2);
    push_front(l2, 1); // Note that this is the first element.
    
    sort(l1);
 
    let result: i32 = if (sum_list(l2) == 36 and list_equals(l1, l2)) {
        1
    } else {
        0
    }

    free_list(l1);
    free_list(l2);

    result
}
